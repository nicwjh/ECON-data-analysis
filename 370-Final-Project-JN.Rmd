title: "ECON 370 Final Project"
author: 'SD:2, 5, 17, 19, 28' 
date: "2022-11-8"
output:
  word_document: default
  pdf_document: default
---
# ============================================
# Set-up
# ============================================
```{r}
library(readr)
library(mosaic)
library(data.table)
library("xlsx")
library(openxlsx)
library(mvtnorm)
library(tidyverse)
library(stringr)
```

# ============================================
# Question 1 - Download Data
# ============================================

Note: r eval = FALSE prevents code chunk from running when data is already downloaded (the "switch" in our code).
Delete eval = FALSE for first run of code to download files.
```{r eval=FALSE} 
for (i in 1998:2010){
  
url1 <- paste("http://www.nber.org/hcris/265-94/rnl_rpt265_94_", i , ".csv",sep = '')
url2 <- paste("http://www.nber.org/hcris/265-94/rnl_nmrc265_94_", i, "_long.csv", sep = '')
url3 <- paste("http://www.nber.org/hcris/265-94/rnl_alpha265_94_", i, "_long.csv", sep = '')
destfile <- paste("./hcris_raw/rnl_rpt265_94_", i , ".csv",sep = '')
download.file(url1,destfile)
destfile <- paste("./hcris_raw/rnl_nmrc265_94_", i, "_long.csv", sep = '')
download.file(url2,destfile)
destfile <- paste("./hcris_raw/rnl_alpha265_94_", i, "_long.csv", sep = '')
download.file(url3,destfile)
}
```

# ============================================
# Question 2 - Cleaning The Data
# ============================================

## Read in raw data
```{r}
# Returns indices of dataframe with matching variable code for subsetting
parse = function(data, match){
  vars = grepl(match, data)
  indices = c()
  for (i in 1:length(vars)){
    if (vars[i]){
      indices = c(indices,i)
    }
  }
  indices
}
## DELETE THIS WHEN DONE: loading Alex's data for part 2
# keeping this here for now for comparison
temp <- read_csv("hcris_panel_raw.csv")
variable_codes <- read.csv("variable_codes.csv")
# 0 pad lines and columns 
for (i in 1:nrow(variable_codes)){
  variable_codes$line[i] = str_pad(variable_codes$line[i], 5, pad = "0")
  variable_codes$column[i] = str_pad(variable_codes$column[i], 4, pad = "0")
}
# generate variable code keys 
variable_codes$key = paste(variable_codes$worksheet, variable_codes$line, variable_codes$column, sep = '')
# Fix typo error in data
variable_codes$key[35] = "S000001001020300"
# Regular expression to parse keys 
toMatch = paste(variable_codes$key, collapse = "|")
# Read in all CSVs 
for (i in 1998:2010){
  
rpt_name = paste("rpt", i, sep = '')
nmrc_name = paste("nmrc", i, sep = '')
alpha_name = paste("alpha", i, sep = '')
rpt <- read_csv(paste("hcris_raw/rnl_rpt265_94_", i , ".csv",sep = ''), show_col_types = F)
nmrc <- read_csv(paste("./hcris_raw/rnl_nmrc265_94_", i, "_long.csv", sep = ''), show_col_types = F)
alpha  <- read_csv(paste("./hcris_raw/rnl_alpha265_94_", i, "_long.csv", sep = ''), show_col_types = F)
nmrc$key = paste(nmrc$wksht_cd, nmrc$line_num, nmrc$clmn_num, sep = '')
alpha$key = paste(alpha$wksht_cd, alpha$line_num, alpha$clmn_num, sep = '')
# Parse alpha and nmrc data for matching variable codes 
indices = parse(nmrc$key, toMatch)
nmrc_parsed = nmrc[indices,]
indices = parse(alpha$key, toMatch)
alpha_parsed = alpha[indices,]
assign(rpt_name, rpt)
assign(nmrc_name, nmrc_parsed)
assign(alpha_name, alpha_parsed)
}
# Clean up environment
rm(rpt, nmrc, alpha, rpt_name, nmrc_name, alpha_name, alpha_parsed, nmrc_parsed)
```

## Reformatting The Raw Data 
```{r}
# Takes a long alpha dataframe, merges variable codes, and returns wide alpha dataframe
long_to_wide_alpha = function(data){
  data$key <- dplyr::recode(
  data$key,
  !!!setNames(as.character(idkey$new), idkey$original)
)
setDT(data)
wide = dcast(data, rpt_rec_num~key, value.var = "alphnmrc_itm_txt")
return(wide)
}
# Takes a long nmrc dataframe, merges variable codes, and returns wide nmrc dataframe
long_to_wide_nmrc = function(data){
  data$key <- dplyr::recode(
  data$key,
  !!!setNames(as.character(idkey$new), idkey$original)
)
setDT(data)
wide = dcast(data, rpt_rec_num~key, value.var = "itm_val_num")
return(wide)
}
# Generate key to merge variable names into dataframe
idkey <- data.frame("original" = variable_codes$key, "new" = variable_codes$variable)
# Declare alpha and nmrc lists to iterate through
alpha_list = list(alpha1998, alpha1999, alpha2000, alpha2001, alpha2002, alpha2003, alpha2004, alpha2005, alpha2006, alpha2007, alpha2008, alpha2009, alpha2010)
nmrc_list = list(nmrc1998, nmrc1999, nmrc2000, nmrc2001, nmrc2002, nmrc2003, nmrc2004, nmrc2005, nmrc2006, nmrc2007, nmrc2008, nmrc2009, nmrc2010)
# Convert all years from long to wide 
for(i in 1998:2010){
  j = i - 1997
  nmrc_wide_name = paste("nmrc_wide_", i, sep = '')
  alpha_wide_name = paste("alpha_wide_", i, sep = '')
  
  nmrc_wide = long_to_wide_nmrc(as.data.frame(nmrc_list[j]))
  alpha_wide = long_to_wide_alpha(as.data.frame(alpha_list[j]))
  
  assign(nmrc_wide_name, nmrc_wide)
  assign(alpha_wide_name, alpha_wide)
  j = j+1
}
# add in missing epo_cost and state columns for 1998 (to match # of columns)
alpha_wide_1998$state = NA
alpha_wide_1998 <- subset(alpha_wide_1998, select=c(1:9, 11, 10))
nmrc_wide_1998$epo_cost = NA
nmrc_wide_1998 <- subset(nmrc_wide_1998, select = c(1:6, 26, 7:25))
wide_alpha_list = list(alpha_wide_1998, alpha_wide_1999, alpha_wide_2000, alpha_wide_2001, alpha_wide_2002, alpha_wide_2003, alpha_wide_2004, alpha_wide_2005, alpha_wide_2006, alpha_wide_2007, alpha_wide_2008, alpha_wide_2009, alpha_wide_2010)
wide_nmrc_list = list(nmrc_wide_1998, nmrc_wide_1999, nmrc_wide_2000, nmrc_wide_2001, nmrc_wide_2002, nmrc_wide_2003, nmrc_wide_2004, nmrc_wide_2005, nmrc_wide_2006, nmrc_wide_2007, nmrc_wide_2008, nmrc_wide_2009, nmrc_wide_2010)
rpt_list = list(rpt1998[c(1,13,14)], rpt1999[c(1,13,14)], rpt2000[c(1,13,14)], rpt2001[c(1,13,14)], rpt2002[c(1,13,14)], rpt2003[c(1,13,14)], rpt2004[c(1,13,14)], rpt2005[c(1,13,14)], rpt2006[c(1,13,14)], rpt2007[c(1,13,14)], rpt2008[c(1,13,14)], rpt2009[c(1,13,14)], rpt2010[c(1,13,14)])
# Merge all years 
for(i in 1998:2010){
  j = i - 1997
  merged_year_name = paste("merged", i, sep = '')
  
  # mege alpha and nmrcr
  merged_year = merge(as.data.frame(wide_nmrc_list[j]), as.data.frame(wide_alpha_list[j]), by = "rpt_rec_num")
  
  # merge fy_bgn_dt and fy_end_dt from rpt data
  merged_year = merge(merged_year, rpt_list[j], by = "rpt_rec_num")
  
  # add year variable
  merged_year$year = i
  
  assign(merged_year_name, merged_year)
  j = j+1
}
# Write all files to CSVs in hcris_cleaned directory 
fwrite(merged1998, file = "hcris_cleaned/hcris_1998.csv")
fwrite(merged1999, file = "hcris_cleaned/hcris_1999.csv")
fwrite(merged2000, file = "hcris_cleaned/hcris_2000.csv")
fwrite(merged2001, file = "hcris_cleaned/hcris_2001.csv")
fwrite(merged2002, file = "hcris_cleaned/hcris_2002.csv")
fwrite(merged2003, file = "hcris_cleaned/hcris_2003.csv")
fwrite(merged2004, file = "hcris_cleaned/hcris_2004.csv")
fwrite(merged2005, file = "hcris_cleaned/hcris_2005.csv")
fwrite(merged2006, file = "hcris_cleaned/hcris_2006.csv")
fwrite(merged2007, file = "hcris_cleaned/hcris_2007.csv")
fwrite(merged2008, file = "hcris_cleaned/hcris_2008.csv")
fwrite(merged2009, file = "hcris_cleaned/hcris_2009.csv")
fwrite(merged2010, file = "hcris_cleaned/hcris_2010.csv")
```

## Cleaning The Data
```{r}
hcris_data <- read_csv("hcris_cleaned/hcris_1998.csv", show_col_types = F)
# rbind all 13 datasets
for (i in 1999:2010){
  current = paste("hcris_cleaned/hcris_", i, ".csv", sep = '')
  to_bind <- read_csv(current, show_col_types = F)
  hcris_data <- rbind(hcris_data, to_bind)
}
# Trying to match Alex's dataset (besides column ordering, which is slightly different)
colnames(hcris_data)[1] = "report_number"
hcris_data$prvdr_num = as.numeric(hcris_data$prvdr_num)
head(hcris_data)

# 1. Drop values where prvdr_num is missing
elim1 <- complete.cases(hcris_data$prvdr_num)
hcris_data <- hcris_data[elim1, ]
# 2. For epo cost, epo net cost, and epo rebates, use absolute value
hcris_data$epo_cost <- abs(hcris_data$epo_cost)
hcris_data$epo_net_cost <- abs(hcris_data$epo_net_cost)
hcris_data$epo_rebates <- abs(hcris_data$epo_rebates)
# 3. Change NAs in epo_rebates to 0 (done)
missingones <- is.na(hcris_data$epo_rebates)
hcris_data$epo_rebates[missingones] <- 0
# 4.
# a) Look where epo cost is missing, epo net cost is not, and epo rebates equals 0. For these observations, set epo cost equal to epo net cost.
hcris_data$epo_cost[is.na(hcris_data$epo_cost) & hcris_data$epo_rebates == 0 & !is.na(hcris_data$epo_net_cost)] = hcris_data$epo_net_cost[is.na(hcris_data$epo_cost) & hcris_data$epo_rebates == 0 & !is.na(hcris_data$epo_net_cost)]
# b) Look where epo cost is missing, epo net cost is not, and epo rebates does not equal 0. Set epo cost to epo net cost plus epo rebates.
hcris_data$epo_cost[is.na(hcris_data$epo_cost) & hcris_data$epo_rebates != 0 & !is.na(hcris_data$epo_net_cost)] = hcris_data$epo_net_cost[is.na(hcris_data$epo_cost) & hcris_data$epo_rebates != 0 & !is.na(hcris_data$epo_net_cost)] + hcris_data$epo_rebates[is.na(hcris_data$epo_cost) & hcris_data$epo_rebates != 0 & !is.na(hcris_data$epo_net_cost)]
# c) Look where epo cost is missing, epo net cost is also missing, epo rebates is 0. Set both epo cost and epo net cost to 0. Be careful and make sure to modify both variables at the same time.
hcris_data <- hcris_data %>%
  mutate(epo_cost = ifelse(is.na(epo_cost) & 
                             epo_rebates == 0 & 
                             is.na(epo_net_cost),0,epo_cost),
         epo_net_cost = ifelse(is.na(epo_cost) & 
                             epo_rebates == 0 & 
                             is.na(epo_net_cost),0,epo_net_cost))

# e) 
hcris_data$epo_net_cost[!is.na(hcris_data$epo_cost) & is.na(hcris_data$epo_net_cost)] = hcris_data$epo_cost[!is.na(hcris_data$epo_cost) & is.na(hcris_data$epo_net_cost)] - hcris_data$epo_rebates[!is.na(hcris_data$epo_cost) & is.na(hcris_data$epo_net_cost)]

# 5. Next, there are some observations where epo cost is less than epo net cost. This should not be able to happen. For these observations, switch epo cost with epo net cost and epo net cost with epo cost. It is important to do this all at one time.
hcris_data <- hcris_data %>%
  mutate(epo_cost = ifelse((epo_cost < epo_net_cost),epo_net_cost,epo_cost),
         epo_net_cost = ifelse((epo_cost < epo_net_cost),epo_cost,epo_net_cost))
# 6
# 7
# 8
# 9
# 10
# 11
# running unit tests for this portion on hcris_test. will eventually replace hcris_test with hcris_data
hcris_test = hcris_data 
sort(unique(hcris_test$chain_identity))
# Regular expressions for string parsing 
f_regex = "^FEN|^FER|^FES|^FR4|^FRE|^FRR|^FRS"
d_regex = "^DAC|^DAN|^DAV|^DAT|^DV"
# declaring new boolean variables so that the loop is more readable 
hcris_test$is_fresenius = grepl(f_regex, hcris_test$chain_identity, ignore.case = TRUE)
hcris_test$is_davita = grepl(d_regex, hcris_test$chain_identity, ignore.case = TRUE)
# @ Sophia don't think we need this if we initialize others first. check out how I set up the loop below
#o_regex = "?!.*(^FER|^FES|^FEN|^FR4E|^FREE|^FREI|^FRES|^FREN|^FREZ|^FRSE|^FRRE|\\bDRESENIUS\\b|^DACITA|^DATIVA|^DAVIATA|^DANITA|^DVITA)"
#set chain_id column default to 0 (includes chain_indicator == "N" and chain_indicator == "NA")
# @Sophia so we are not subsetting to remove NA anymore. If chain_indicator == "NA", we'll set chain_id to 0 as well
hcris_test$chain_id = 0
for (i in 1:nrow(hcris_test)){
  if (hcris_test$is_fresenius[i]){ # Fresenius chain
    hcris_test$chain_id[i] = 3
    hcris_test$chain_identity[i] = "Fresenius"
  }
  else if (hcris_test$is_davita[i]){ # Davita chain
    hcris_test$chain_id[i] = 2
    hcris_test$chain_identity[i] = "DaVita"
  }
  else if (!is.na(hcris_test$chain_indicator[i]) & hcris_test$chain_indicator[i] == "Y" & !is.na(hcris_test$chain_identity[i]) & hcris_test$chain_identity[i] != ""){ # not Fresenius or Davita, but has a chain indicator/non-empty chain_identity (other)
    hcris_test$chain_id[i] = 1
    hcris_test$chain_identity[i] = "Other"
  }
  else{ # not Fresenius/Davita/other
    hcris_test$chain_identity[i] = "Not chain"
  }
}
## ASK ALEX: why are there some DaVita and Fresenius entries with N for chain_indicator? should be a simple fix if these are meant to be included. Also, what else do we need to do to "clean" the chain variables? More standardizing names?
## this works for fresenius and davita but not for the others
#temp3[grepl(f_regex,chain_identity,ignore.case = TRUE),chain_identity := 'FRESENIUS']
#temp3[grepl(d_regex,chain_identity,ignore.case = TRUE),chain_identity := 'DAVITA']
## I think the issue with this one is the regex, not sure how I should change it
#temp3[grepl(o_regex,chain_identity,ignore.case = TRUE),chain_identity := 'OTHER']
## this works to change chain_identity but then sets everything in chain_id to "other"
#temp3$chain_id[temp3$chain_id == 1] = (temp3$chain_identity[temp3$chain_id == 1] = "OTHER")
#temp3$chain_id[temp3$chain_id == 2] = (temp3$chain_identity[temp3$chain_id == 2] = "DAVITA")
#temp3$chain_id[temp3$chain_id == 3] = (temp3$chain_identity[temp3$chain_id == 3] = "FRESENIUS")
# 12
```


# ============================================
# Question 3 - Analysis 
# ============================================
```{r}
```
Questions for Alex 
1. 1998 merged data: missing epo_cost and state. just declare as NA? 
length(unique(alpha1998$key)) + length(unique(nmrc1998$key)) == 33
length(unique(alpha1999$key)) + length(unique(nmrc1999$key)) == 35 (for all other years also)

2. my reformatted data is not exactly equal. Is this a problem? Example output: 
> all.equal(temp, hcris_data)
[1] "Attributes: < Names: 1 string mismatch >"                                            
[2] "Attributes: < Length mismatch: comparison on first 2 components >"                   
[3] "Attributes: < Component “class”: Lengths (4, 3) differ (string compare on first 3) >"
[4] "Attributes: < Component “class”: 3 string mismatches >"                              
[5] "Attributes: < Component 2: target is externalptr, current is numeric >"              
[6] "Component “zip_code”: 238 string mismatches" 
> temp$zip_code[335]
[1] "6902"
> hcris_data$zip_code[335]
[1] "06902"
3. Cleaning part 11
check if how we're renaming it is OK 

Other notes 

1. epo_code and state missing in 1998 